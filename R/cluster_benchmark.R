

#' Simulate one (sub)module using input HCD of dataset and synthetic PCs
#'
#' @details This is modular version of [get_cloned_dataset()], see that function to get meaning of input data. 
#' 
#' Additional parameters `cluster_tuple` and `up_to` are passed to [extract_subclustering()]. 
#' They control which (sub)cluster to simulate and how many sublayers of it.
#'
#' If `add_noise=TRUE`, then missing variance in the module is complemented by random noise in the following manner:
#' The variance of each variable in the module will be eqial to
#' that variable in X, but variance contained in the module that carries
#'  contribution from PCs will only use PCs from cluster `cluster_tuple`
#' and `up_to` sublayers nontained in it.
#'
#' @param X An input dataset matrix where rows are samples and columns variables
#' @param cluster_tuple Name of the module (from `hclustering_list`) to simulate.
#' @param hcluster_blockPCA Reconstructions of blocks defined by clusters from \code{hclustering_list}. Produced by \code{sublusterNreconstruct} or by \code{initial_clusterNreconstruct} or \code{blockwise_PCA_reconstruction}.
#' @param hclustering_list  A list encoding cluster membership, such as one produced by \code{subclusterNreconstruct} or \code{subdivide_cluster} or an instance of \code{HCCSim_clustering_list}.
#' @param cloned_PCmatrix Matrix of PCs simulating PCs in \code{hcluster_blockPCA}. Number of rows of that matrix determines number of samples to generate in output dataset. Can be generated by \code{cloned_normalPC_matrix} or \code{cloned_metalogPC_matrix} functions.
#' @param noise_variances Variances of random noise to add to each variable in the module, must be of length `length(hclustering_list[[cluster_tuple]])`.
#' @param uncenter If \code{TRUE}, then means of \code{X} will be added back to synthetic data. Otherwise, generated data is zero centered.
#' @param up_to Number of sublayers of module `cluster_tuple` to include in the simulation. If `NULL`, are layers are included, if it is 0, only the part of the signal of the module ID-ed by `cluster_tuple` is included, if it exceeds the number of available sublayers of `cluster_tuple`, error is raised.
#' @return A matrix of dimension \code{nrow(cloned_PCmatrix)} x \code{length(hclustering_list[[cluster_tuple]])}, containing synthetic data according to `up_to` specification, generated by using PCs from \code{cloned_PCmatrix} and original coefficients of linear combinations of PCs from \code{hcluster_blockPCA}.
#' @examples
#' data(brca)
#' data(brca_clusters)
#' lvl1<- initial_clusterNreconstruct(X= brca, X_variances=matrixStats::colVars(brca),
#'				        clustering_vector=brca_clusters)
#' lvl2<- subclusterNreconstruct(X=brca,
#' 				 X_variances= matrixStats::colVars(brca),
#' 				 hclustering_list= lvl1$clustering_list,
#'                               hcluster_PCA_blocks=lvl1$cluster_blockPCA,
#'                               clfun2=similarity_based_hclust,
#'                               clfun2OtherArgs_constant=list(method="complete" ),
#'				 clfun2OtherArgs_ranges= list(n_group=2:7)) 
#'
#' ## 2 level HCS(n): normal distribution of PCs
#' PC_generator_matrix( lvl2$hcluster_blockPCA) -> PCmat2
#' cloned_PC_N<- cloned_normalPC_matrix(PCmat2)
#' #compute missing variance of 2lvl rec.
#' X_r2<- get_full_reconstruction(brca, lvl2$hcluster_blockPCA, lvl2$hclustering_list,
#' 				  add_noise=FALSE) #crucial arg to compute missing variance properly!
#' noise_variances2<- matrixStats::colVars(brca-X_r2)
#' #First - full simulation. Then - do modular version and compare results for the module, should be similar
#' X_s2<- get_cloned_dataset(brca, lvl2$hcluster_blockPCA, 
#'				lvl2$hclustering_list,
#'				cloned_PC_N,
#' 				noise_variances= noise_variances2)
#' module_2<-simulate_module(X=brca, cluster_tuple='2',
#' 			     hcluster_blockPCA= lvl2$hcluster_blockPCA,
#'			     hclustering_list=lvl2$hclustering_list,
#'			     cloned_PCmatrix=cloned_PC_N,
#'			     noise_variances= noise_variances2[ lvl2$hclustering_list[['2']] ])
#' c1<- corfast(X_s2[, lvl2$hclustering_list[['2']]])	
#' c2<- corfast(module_2)
#' MSE(c1,c2)
#' cc1<- ccfast(c1^2)
#' cc2<- ccfast(c2^2)
#' par(mfrow=c(1,3))
#' hist(cc1, main="local cluster coef., in module 2 from full sim")
#' plot(cc1,cc2, main="cc module 2, full sim vs modular")	
#' hist(cc2, main="local cluster coef., in module 2 from full modular ver.")
#' @export
simulate_module<- function(X, cluster_tuple,
 			   hcluster_blockPCA,
			   hclustering_list,
			   cloned_PCmatrix,
			   noise_variances=NULL,
			   uncenter=TRUE,
			   up_to=NULL
			   ) {
	X_s= matrix(nrow=nrow(cloned_PCmatrix), ncol= ncol(X) ) 
	X_s[,]=0
	colnames(X_s)<- colnames(X)
	subclusters<-extract_subclustering( cluster_tuple, hclustering_list,up_to)	
	subclusters_PCA<- hcluster_blockPCA[ names(subclusters) ]
	get_max_lvl(subclusters) -> end_lvl
	# HCR.R for p.() definition
	length(p.(cluster_tuple)) -> start_lvl
	for (layer_number in start_lvl:end_lvl) {
	   # since cluster placements are in temrs of X,
	   # we will put the subcluster here and transfert it to mod then
	   X_aux= matrix(nrow=nrow(cloned_PCmatrix), ncol= ncol(X) ) 
	   X_aux[,]=0
	   subclusters_thisLayer<- get_partition_at_g(subclusters, layer_number)
	   print(names(subclusters_thisLayer))
	   subclusters_PCA_thisLayer<- subclusters_PCA[ names(subclusters_thisLayer) ]
	   print(names(subclusters_PCA_thisLayer))
	   for (K in names(subclusters_PCA_thisLayer) )
	  	subclusters_PCA_thisLayer[[K]]$reconstruction <- cloned_PCmatrix[, colnames(cloned_PCmatrix)==K,drop=FALSE] %*% subclusters_PCA_thisLayer[[K]]$Vt
	    allocate_blocks(where=X_aux, blockwise_PCA=subclusters_PCA_thisLayer) -> X_aux
	    X_s = X_s + X_aux 
	   }
	# now we take just the subcluster
	mod=X_s[, subclusters[[cluster_tuple]], drop=FALSE ] 
	if (uncenter | (!is.null(noise_variances)))
		X_mod<- X[, subclusters[[cluster_tuple]], drop=FALSE ] 
	if (!is.null(noise_variances)) mod<-add_noise2(mod,noise_variances)
	if (uncenter) { colMeans(X_mod)-> meansX
		for(j in 1:ncol(X_mod)) mod[,j] = mod[,j] + meansX[[j]]
	      }
	return(mod)
}

