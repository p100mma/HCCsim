#' Simulate data altering global and inter-cluster connectivities of the reference modules
#'
#' Given an output of `HCR` procedure and a set of fitted, simulated `PCs` of the clusters contained in the supplied
#' decomposition of the correlation structure, function will simulate from the altered distribution, modifying
#' global correaltion strength and inter-cluster link strengths.
#'
#' @details This function is a modified version [get_cloned_dataset()] for constructing benchmarks for clustering 
#' algoritmhs. 
#' Initial clusters are altered in a way to make the problem increasingly easier or harder to solve by varing two
#' parameters `A` and `prop_i`.
#'
#' The higher the `prop_i` , the more samples are drawn from identical version of the simulated data but with module at  specified layer simulated independently.
#' It is actually probability of drawing a sample from data with independent modules from the surface partition
#' (lvl 1) of `hclustering_list`.
#' This ensures internal correlation structure of the modules stays realistic, only the between-correlations 
#' change - modules get more connected as `prop_i` is lowered down.
#'
#' `0<= A <= pi/2` specifies the amplitude of random noise altering all variables in the network.
#' The higher the `A`, the more share in variance of each variable is given to the independent noise term.
#' Thus raising `A` lowers overall correaltion strength.
#' This is achieved by multiplying explained and noise parts of each variable by `x,y` dependent on `A`.
#' Each `X_i` from plain HCS is `X^P_i + E_i`, where `X^P_i` is part explained by PCs and `E_i` is independent
#' noise term. Terms are multiplied by `x,y` to create modified variable `X^M_i:= x*X^P_i + y*E_i` which 
#' variance is set to be equal to the variance of original `X_i`. Feasible `x,y` lie on the ellipse 
#' with width/height dependent on the ratio of the noise term to overall variance of the variable:
#' `V(X^P_i) + V(E_i) = x^2 V(X^P_i) + y^2 V(E_i)`, setting `p= V(X^P_i), e=V(E_i), c= [ e ]/[p + e]` the equation
#' is ` 1 = [x^2/((1-c)^(-1))] + [ y^2/( c^(-1) ) ]`, which can be parametrized to a curve
#' `(x,y) = ( [1-c]^(-1/2) cos(A) , c^(-1/2) sin(A) )`.  Note that how `x,y` changes with `A` is specific to each
#' variable and it is intended to be like that.
#'
#' Both parameters are at play at the same time. This means the dataset will consist of `prop_i` samples from
#' data with independent modules `DATA_I` and `1-prop_i` from the data with correlated modules `DATA_C`, where
#' each variable in `DATA_I`, and `DATA_C` is the modified version weighted by `x,y` specific to that variable and
#' value of `A` parameter. Both paramteres set to `NULL` means identical behaviour to `[get_cloned_dataset()]`.
#'
#' @param X An input dataset matrix where rows are samples and columns variables
#' @param hcluster_blockPCA Reconstructions of blocks defined by clusters from \code{hclustering_list}. Produced by \code{sublusterNreconstruct} or by \code{initial_clusterNreconstruct} or \code{blockwise_PCA_reconstruction}.
#' @param hclustering_list  A list encoding cluster membership, such as one produced by \code{subclusterNreconstruct} or \code{subdivide_cluster} or an instance of \code{HCCSim_clustering_list}.
#' @param cloned_PCmatrix Matrix of PCs simulating PCs in \code{hcluster_blockPCA}. Number of rows of that matrix determines number of samples to generate in output dataset. Can be generated by \code{cloned_normalPC_matrix} or \code{cloned_metalogPC_matrix} functions.
#' @param noise_variances Variances of random noise to add to each variable in the module, must be of length `length(hclustering_list[[cluster_tuple]])`.
#' @param uncenter If \code{TRUE}, then means of \code{X} will be added back to synthetic data. Otherwise, generated data is zero centered.
#' @param A Parameter in `[0, pi/2]` specifying amplitude of random noise of simulated variables, see details. If `NULL`, then no alternation of the natural ratios in the data is done. The lower the value, the lesser overall magnitude of correlation in the data.
#' @param prop_i A proportion of samples to generate from distribution where each module from lvl 1 of `hclustering_list` is simulated independently. If `NULL`, all samples come from the data with normal between module correaltions. The bigger the value, the less modules are correlated with each other. 
#' @return A matrix of dimension \code{nrow(cloned_PCmatrix)} x \code{length(hclustering_list[[cluster_tuple]])}, containing synthetic data according to `up_to` specification, generated by using PCs from \code{cloned_PCmatrix} and original coefficients of linear combinations of PCs from \code{hcluster_blockPCA}.
#' @examples
#' data(brca)
#' data(brca_clusters)
#' lvl1<- initial_clusterNreconstruct(X= brca, X_variances=matrixStats::colVars(brca),
#'				        clustering_vector=brca_clusters)
#' lvl2<- subclusterNreconstruct(X=brca,
#' 				 X_variances= matrixStats::colVars(brca),
#' 				 hclustering_list= lvl1$clustering_list,
#'                               hcluster_PCA_blocks=lvl1$cluster_blockPCA,
#'                               clfun2=similarity_based_hclust,
#'                               clfun2OtherArgs_constant=list(method="complete" ),
#'				 clfun2OtherArgs_ranges= list(n_group=2:7)) 
#'
#' ## 2 level HCS(n): normal distribution of PCs
#' PC_generator_matrix( lvl2$hcluster_blockPCA) -> PCmat2
#' cloned_PC_N<- cloned_normalPC_matrix(PCmat2)
#' #compute missing variance of 2lvl rec.
#' X_r2<- get_full_reconstruction(brca, lvl2$hcluster_blockPCA, lvl2$hclustering_list,
#' 				  add_noise=FALSE) #crucial arg to compute missing variance properly!
#' noise_variances2<- matrixStats::colVars(brca-X_r2)
#' #First - full simulation. Then - compare with altered version
#' X_s2<- get_cloned_dataset(brca, lvl2$hcluster_blockPCA, 
#'				lvl2$hclustering_list,
#'				cloned_PC_N,
#' 				noise_variances= noise_variances2)
#' @export
generate_cluster_benchmark<- function(X, 
 			   hcluster_blockPCA,
			   hclustering_list,
			   cloned_PCmatrix,
			   noise_variances=NULL,
			   uncenter=TRUE,
			   A=NULL,
			   prop_i=NULL
			   ) {
if (!is.null(A)) amplitude=TRUE else amplitude=FALSE
if (!is.null(prop_i)) inter=TRUE else inter=FALSE
if (amplitude) stopifnot( (A >= 0) && (A <= pi) )
if (amplitude) if (is.null(noise_variances)) stop(
	"If A is set to numeric value then noise_variances must be given"
	)
if (inter) stopifnot( (inter >=0) && (inter <= 1 ) )

if (inter) X_idp<- X #placeholder of independent parts of data
if (inter) X_idp[,]=0 

X_plain = get_cloned_dataset(X=X, hcluster_blockPCA=hcluster_blockPCA,
			     hclustering_list=hclustering_list,
			     cloned_PCmatrix=cloned_PCmatrix,
			    #last two steps are performed here instead
			     noise_variances=NULL,
		             uncenter=FALSE)

#handle independent data
if (inter) {
	get_partition_at_g( hclustering_list,1) -> g_j_clustering
	names(g_j_clustering) -> lvl1_clusterNames 
	# for each of the lvl 1 clusters
	# simulate the cluster independently and put it where it belongs
	# all layers are simulated (`up_to` is not specified)
	for (cl_nr in lvl1_clusterNames) {
 	X_idp[, 
		hclustering_list[[ cl_nr ]]
	     ]<-simulate_module(X=X, cluster_tuple=cl_nr,
 			     hcluster_blockPCA= hcluster_blockPCA,
			     hclustering_list= hclustering_list,
			     cloned_PCmatrix=cloned_PCmatrix,
		#do not add noise yet. This will be done
		#differently if amplitude is TRUE
			     noise_variances= NULL,
			     uncenter=FALSE)
	}	
}
if (amplitude) { #handle A here
	totalVars<- colVars(X)
	noise_shares= noise_variances/totalVars
	cosWeights<- (1-noise_shares)^(-1/2)	
	cosWeights[ (1-noise_shares)^(-1) < 1e-16 ] = 0
	sinWeights<- (noise_shares)^(-1/2)	
	pcXcoef= cos(A)*cosWeights
	Ecoef= sin(A)*sinWeights
	inf_pc<- !is.finite(pcXcoef)
	inf_E<- !is.finite(Ecoef)
	pcXcoef[ (inf_pc | inf_E ) ] <- Ecoef[ (inf_pc | inf_E ) ] <- 1
	noise_variances= noise_variances*(Ecoef^2)
	for (j in 1:ncol(X)) X_plain[,j] = pcXcoef[[j]]*X_plain[,j]

	if (inter) { #handle A for independent module data
	for (j in 1:ncol(X)) X_idp[,j] = pcXcoef[[j]]*X_idp[,j]
	}
	
	} 

if (inter) { #finally, sample from indepd
	idp_mask<- sample(c(TRUE,FALSE), nrow(X_plain), replace=TRUE,
			  prob=c(prop_i, 1-prop_i))
	print(sum(idp_mask))
	X_plain[idp_mask,]<- X_idp[idp_mask,]	
	}

if (!is.null(noise_variances))
 {
 X_plain<- add_noise2(X_plain, noise_variances)
 }

if (uncenter) { colMeans(X)-> meansX
		for(j in 1:ncol(X)) X_plain[,j] = X_plain[,j] + meansX[[j]]
	      }
return(X_plain)
}

