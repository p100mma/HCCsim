% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/HCS.R
\name{simulate_module}
\alias{simulate_module}
\title{Simulate one (sub)module using input HCD of dataset and synthetic PCs}
\usage{
simulate_module(
  X,
  cluster_tuple,
  hcluster_blockPCA,
  hclustering_list,
  cloned_PCmatrix,
  noise_variances = NULL,
  uncenter = TRUE,
  up_to = NULL
)
}
\arguments{
\item{X}{An input dataset matrix where rows are samples and columns variables}

\item{cluster_tuple}{Name of the module (from \code{hclustering_list}) to simulate.}

\item{hcluster_blockPCA}{Reconstructions of blocks defined by clusters from \code{hclustering_list}. Produced by \code{sublusterNreconstruct} or by \code{initial_clusterNreconstruct} or \code{blockwise_PCA_reconstruction}.}

\item{hclustering_list}{A list encoding cluster membership, such as one produced by \code{subclusterNreconstruct} or \code{subdivide_cluster} or an instance of \code{HCCSim_clustering_list}.}

\item{cloned_PCmatrix}{Matrix of PCs simulating PCs in \code{hcluster_blockPCA}. Number of rows of that matrix determines number of samples to generate in output dataset. Can be generated by \code{cloned_normalPC_matrix} or \code{cloned_metalogPC_matrix} functions.}

\item{noise_variances}{Variances of random noise to add to each variable in the module, must be of length \code{length(hclustering_list[[cluster_tuple]])}.}

\item{uncenter}{If \code{TRUE}, then means of \code{X} will be added back to synthetic data. Otherwise, generated data is zero centered.}

\item{up_to}{Number of sublayers of module \code{cluster_tuple} to include in the simulation. If \code{NULL}, are layers are included, if it is 0, only the part of the signal of the module ID-ed by \code{cluster_tuple} is included, if it exceeds the number of available sublayers of \code{cluster_tuple}, error is raised.}
}
\value{
A matrix of dimension \code{nrow(cloned_PCmatrix)} x \code{length(hclustering_list[[cluster_tuple]])}, containing synthetic data according to \code{up_to} specification, generated by using PCs from \code{cloned_PCmatrix} and original coefficients of linear combinations of PCs from \code{hcluster_blockPCA}.
}
\description{
Simulate one (sub)module using input HCD of dataset and synthetic PCs
}
\details{
This is modular version of \code{\link[=get_cloned_dataset]{get_cloned_dataset()}}, see that function to get meaning of input data.

Additional parameters \code{cluster_tuple} and \code{up_to} are passed to \code{\link[=extract_subclustering]{extract_subclustering()}}.
They control which (sub)cluster to simulate and how many sublayers of it.

If \code{add_noise=TRUE}, then missing variance in the module is complemented by random noise in the following manner:
The variance of each variable in the module will be eqial to
that variable in X, but variance contained in the module that carries
contribution from PCs will only use PCs from cluster \code{cluster_tuple}
and \code{up_to} sublayers nontained in it.
}
\examples{
data(brca)
data(brca_clusters)
lvl1<- initial_clusterNreconstruct(X= brca, X_variances=matrixStats::colVars(brca),
			        clustering_vector=brca_clusters)
lvl2<- subclusterNreconstruct(X=brca,
				 X_variances= matrixStats::colVars(brca),
				 hclustering_list= lvl1$clustering_list,
                              hcluster_PCA_blocks=lvl1$cluster_blockPCA,
                              clfun2=similarity_based_hclust,
                              clfun2OtherArgs_constant=list(method="complete" ),
			 clfun2OtherArgs_ranges= list(n_group=2:7)) 

## 2 level HCS(n): normal distribution of PCs
PC_generator_matrix( lvl2$hcluster_blockPCA) -> PCmat2
cloned_PC_N<- cloned_normalPC_matrix(PCmat2)
#compute missing variance of 2lvl rec.
X_r2<- get_full_reconstruction(brca, lvl2$hcluster_blockPCA, lvl2$hclustering_list,
				  add_noise=FALSE) #crucial arg to compute missing variance properly!
noise_variances2<- matrixStats::colVars(brca-X_r2)
#First - full simulation. Then - do modular version and compare results for the module, should be similar
X_s2<- get_cloned_dataset(brca, lvl2$hcluster_blockPCA, 
			lvl2$hclustering_list,
			cloned_PC_N,
				noise_variances= noise_variances2)
module_2<-simulate_module(X=brca, cluster_tuple='2',
			     hcluster_blockPCA= lvl2$hcluster_blockPCA,
		     hclustering_list=lvl2$hclustering_list,
		     cloned_PCmatrix=cloned_PC_N,
		     noise_variances= noise_variances2[ lvl2$hclustering_list[['2']] ])
c1<- corfast(X_s2[, lvl2$hclustering_list[['2']]])	
c2<- corfast(module_2)
MSE(c1,c2)
cc1<- ccfast(c1^2)
cc2<- ccfast(c2^2)
par(mfrow=c(1,3))
hist(cc1, main="local cluster coef., in module 2 from full sim")
plot(cc1,cc2, main="cc module 2, full sim vs modular")	
hist(cc2, main="local cluster coef., in module 2 from full modular ver.")
}
