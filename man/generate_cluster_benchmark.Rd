% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cluster_benchmark.R
\name{generate_cluster_benchmark}
\alias{generate_cluster_benchmark}
\title{Simulate data altering global and inter-cluster connectivities of the reference modules}
\usage{
generate_cluster_benchmark(
  X,
  hcluster_blockPCA,
  hclustering_list,
  cloned_PCmatrix,
  noise_variances = NULL,
  uncenter = TRUE,
  A = NULL,
  prop_i = NULL
)
}
\arguments{
\item{X}{An input dataset matrix where rows are samples and columns variables}

\item{hcluster_blockPCA}{Reconstructions of blocks defined by clusters from \code{hclustering_list}. Produced by \code{sublusterNreconstruct} or by \code{initial_clusterNreconstruct} or \code{blockwise_PCA_reconstruction}.}

\item{hclustering_list}{A list encoding cluster membership, such as one produced by \code{subclusterNreconstruct} or \code{subdivide_cluster} or an instance of \code{HCCSim_clustering_list}.}

\item{cloned_PCmatrix}{Matrix of PCs simulating PCs in \code{hcluster_blockPCA}. Number of rows of that matrix determines number of samples to generate in output dataset. Can be generated by \code{cloned_normalPC_matrix} or \code{cloned_metalogPC_matrix} functions.}

\item{noise_variances}{Variances of random noise to add to each variable in the module, must be of length \code{length(hclustering_list[[cluster_tuple]])}.}

\item{uncenter}{If \code{TRUE}, then means of \code{X} will be added back to synthetic data. Otherwise, generated data is zero centered.}

\item{A}{Parameter in \verb{[0, pi/2]} specifying amplitude of random noise of simulated variables, see details. If \code{NULL}, then no alternation of the natural ratios in the data is done. The lower the value, the lesser overall magnitude of correlation in the data.}

\item{prop_i}{A proportion of samples to generate from distribution where each module from lvl 1 of \code{hclustering_list} is simulated independently. If \code{NULL}, all samples come from the data with normal between module correaltions. The bigger the value, the less modules are correlated with each other.}
}
\value{
A matrix of dimension \code{nrow(cloned_PCmatrix)} x \code{length(hclustering_list[[cluster_tuple]])}, containing synthetic data according to \code{up_to} specification, generated by using PCs from \code{cloned_PCmatrix} and original coefficients of linear combinations of PCs from \code{hcluster_blockPCA}.
}
\description{
Given an output of \code{HCR} procedure and a set of fitted, simulated \code{PCs} of the clusters contained in the supplied
decomposition of the correlation structure, function will simulate from the altered distribution, modifying
global correaltion strength and inter-cluster link strengths.
}
\details{
This function is a modified version \code{\link[=get_cloned_dataset]{get_cloned_dataset()}} for constructing benchmarks for clustering
algoritmhs.
Initial clusters are altered in a way to make the problem increasingly easier or harder to solve by varing two
parameters \code{A} and \code{prop_i}.

The higher the \code{prop_i} , the more samples are drawn from identical version of the simulated data but with module at  specified layer simulated independently.
It is actually probability of drawing a sample from data with independent modules from the surface partition
(lvl 1) of \code{hclustering_list}.
This ensures internal correlation structure of the modules stays realistic, only the between-correlations
change - modules get more connected as \code{prop_i} is lowered down.

\verb{0<= A <= pi/2} specifies the amplitude of random noise altering all variables in the network.
The higher the \code{A}, the more share in variance of each variable is given to the independent noise term.
Thus raising \code{A} lowers overall correaltion strength.
This is achieved by multiplying explained and noise parts of each variable by \verb{x,y} dependent on \code{A}.
Each \code{X_i} from plain HCS is \code{X^P_i + E_i}, where \code{X^P_i} is part explained by PCs and \code{E_i} is independent
noise term. Terms are multiplied by \verb{x,y} to create modified variable \code{X^M_i:= x*X^P_i + y*E_i} which
variance is set to be equal to the variance of original \code{X_i}. Feasible \verb{x,y} lie on the ellipse
with width/height dependent on the ratio of the noise term to overall variance of the variable:
\verb{V(X^P_i) + V(E_i) = x^2 V(X^P_i) + y^2 V(E_i)}, setting \verb{p= V(X^P_i), e=V(E_i), c= [ e ]/[p + e]} the equation
is \verb{ 1 = [x^2/((1-c)^(-1))] + [ y^2/( c^(-1) ) ]}, which can be parametrized to a curve
\verb{(x,y) = ( [1-c]^(-1/2) cos(A) , c^(-1/2) sin(A) )}.  Note that how \verb{x,y} changes with \code{A} is specific to each
variable and it is intended to be like that.

Both parameters are at play at the same time. This means the dataset will consist of \code{prop_i} samples from
data with independent modules \code{DATA_I} and \code{1-prop_i} from the data with correlated modules \code{DATA_C}, where
each variable in \code{DATA_I}, and \code{DATA_C} is the modified version weighted by \verb{x,y} specific to that variable and
value of \code{A} parameter. Both paramteres set to \code{NULL} means identical behaviour to \verb{[get_cloned_dataset()]}.
}
\examples{
data(brca)
data(brca_clusters)
lvl1<- initial_clusterNreconstruct(X= brca, X_variances=matrixStats::colVars(brca),
			        clustering_vector=brca_clusters)
lvl2<- subclusterNreconstruct(X=brca,
				 X_variances= matrixStats::colVars(brca),
				 hclustering_list= lvl1$clustering_list,
                              hcluster_PCA_blocks=lvl1$cluster_blockPCA,
                              clfun2=similarity_based_hclust,
                              clfun2OtherArgs_constant=list(method="complete" ),
			 clfun2OtherArgs_ranges= list(n_group=2:7)) 

## 2 level HCS(n): normal distribution of PCs
PC_generator_matrix( lvl2$hcluster_blockPCA) -> PCmat2
cloned_PC_N<- cloned_normalPC_matrix(PCmat2)
#compute missing variance of 2lvl rec.
X_r2<- get_full_reconstruction(brca, lvl2$hcluster_blockPCA, lvl2$hclustering_list,
				  add_noise=FALSE) #crucial arg to compute missing variance properly!
noise_variances2<- matrixStats::colVars(brca-X_r2)
#First - full simulation. Then - compare with altered version
X_s2<- get_cloned_dataset(brca, lvl2$hcluster_blockPCA, 
			lvl2$hclustering_list,
			cloned_PC_N,
				noise_variances= noise_variances2)
}
